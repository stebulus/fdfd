#!@bash@/bin/bash
set -euo pipefail
me=$(@coreutils@/bin/basename "${BASH_SOURCE[0]}")
here=$(@coreutils@/bin/dirname "${BASH_SOURCE[0]}")

XSD_DATE_FMT="%FT%T.%N%:z"

cleanup() { if [ -v tmp ]; then rm -rf "$tmp"; fi }
trap cleanup EXIT

require_tmp() {
    declare -g tmp
    if [ ! -v tmp ]; then
        tmp=$(@coreutils@/bin/mktemp --directory --tmpdir "$me".XXXXXXXX)
    fi
}

command_extract_atom() {
    extract_atom "$@"
}

command_extract_rss() {
    extract_rss "$@"
}

command_fetch() {
    if [ $# -lt 1 ]; then exit_usage "fetch URL [URL ...]"; fi
    local url fetchbase fetchdir got_items now
    for url in "$@"; do
        fetchdir=$(new_data_subdir)
        {
            preamble_turtle
            echo "<.> rdf:type amfd:fetch ;"
            echo "  amfd:fetch-url <$url> ;"
            now=$(timestamp)
            echo "  amfd:when-start $now ."
            @curl@/bin/curl \
                --compressed \
                --dump-header "$fetchdir"/headers \
                --location \
                --output "$fetchdir"/entity \
                --show-error \
                --silent \
                "$url"
            extract_rss "$fetchdir"/entity
            extract_atom "$fetchdir"/entity
            now=$(timestamp)
            echo "  amfd:when-end $now ."
        } >"$fetchdir"/facts.ttl
        echo "$fetchdir"/facts.ttl
    done
}

command_merge() {
    if [ $# -lt 1 ]; then exit_usage "merge DBDIR [FILE ...]"; fi
    local dbdir
    dbdir=$1
    shift
    if [ $# -eq 0 ]; then command_merge "$dbdir" -; fi
    for f in "$@"; do
        fullf=$(@coreutils@/bin/readlink -e "$f")
        g=$(nonce 20)
        {
            echo "# $fullf"
            @coreutils@/bin/date +"# ${XSD_DATE_FMT}"
            @jena@/bin/turtle "$f"
        } >"$dbdir/.new.$g"
        @coreutils@/bin/mv "$dbdir/.new.$g" "$dbdir/$g"
    done
}

command_query() {
    if [ $# -ne 2 ]; then exit_usage "query DBDIR QUERY"; fi
    local dbdir query work
    dbdir=$1
    query=$2
    work=$(subtmpdir)
    @coreutils@/bin/cat "$dbdir"/* >"$work"/all-facts.nt
    {
        preamble_sparql
        echo "$query"
    } >"$work"/query.rq
    @jena@/bin/sparql \
        --results json \
        --data "$work"/all-facts.nt \
        --query "$work"/query.rq
}

command_unposted() {
    if [ $# -ne 1 ]; then exit_usage "unposted DBDIR"; fi
    command_query "$1" '
        SELECT ?link ?title ?sourceurl ?date
        WHERE {
            ?item a amfd:item ;
                amfd:link ?link ;
                amfd:review/amfd:worth-posting true .
            OPTIONAL { ?item dc:title ?title }
            OPTIONAL { ?item dc:source/amfd:fetch-url ?sourceurl }
            OPTIONAL { ?item dc:date ?date }
            OPTIONAL { ?item amfd:post ?post }
            FILTER (!bound(?post))
        }
        '
}

command_unreviewed() {
    if [ $# -ne 1 ]; then exit_usage "unreviewed DBDIR"; fi
    command_query "$1" '
        SELECT ?link ?title ?sourceurl ?date
        WHERE {
            ?item a amfd:item ; amfd:link ?link .
            OPTIONAL { ?item dc:title ?title }
            OPTIONAL { ?item dc:source/amfd:fetch-url ?sourceurl }
            OPTIONAL { ?item dc:date ?date }
            OPTIONAL { ?item amfd:review ?review }
            FILTER (!bound(?review))
        }
        '
}

extract_atom() {
    for f in "$@"; do
        itemsdir=$(xml_pieces /feed/entry "$f")
        for g in "$itemsdir"/*; do
            linksdir=$(xml_pieces link "$g")
            for h in "$linksdir"/*; do
                @awk@/bin/awk '
                    BEGIN { a["rel"] = "alternate" }
                    /^link\/@/ {
                        i = index($0, "@")
                        j = index($0, "=")
                        a[substr($0, i+1, j-1)] = substr($0, j+1)
                    }
                    END {
                        if (a["rel"] == "alternate" && "href" in a)
                            print "properlink=" a["href"]
                    }
                    ' "$h"
            done >>"$g"
            @awk@/bin/awk -f "$here"/../lib/items.awk --source '
                $1 == "title" { stash("title") }
                $1 == "properlink" { stash("link") }
                $1 == "id" { stash("id") }
                $1 == "updated" { stash("date") }
                ' "$g"
        done
    done
}

extract_rss() {
    for f in "$@"; do
        itemsdir=$(xml_pieces /rss/channel/item "$f")
        for f in "$itemsdir"/*; do
            @coreutils@/bin/cat "$f" |
            while IFS='=' read k v; do
                case "$k" in
                    pubDate) v=$(@coreutils@/bin/date +"${XSD_DATE_FMT}" --date="$v") ;;
                    *) ;;
                esac
                echo "$k=$v"
            done |
            @awk@/bin/awk -f "$here"/../lib/items.awk --source '
                $1 == "title" { stash("title") }
                $1 == "link" { stash("link") }
                $1 == "guid" { stash("id") }
                $1 == "pubDate" { stash("date") }
                '
        done
    done
}

new_data_subdir() {
    local chars d
    chars=$(nonce 20)
    @coreutils@/bin/mkdir -p "$chars"
    echo "$chars"
}

nonce() {
    @coreutils@/bin/dd if=/dev/urandom count="$1" bs=1 2>/dev/null |
    @coreutils@/bin/base32 |
    @coreutils@/bin/tr A-Z a-z
}

preamble_raw() {
    echo "amfd: <tag:amotlpaa.org,2016:fdfd/>"
    echo "dc: <http://purl.org/dc/terms/>"
    echo "rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
    echo "xsd: <http://www.w3.org/2001/XMLSchema#>"
}

preamble_sparql() {
    preamble_raw | @sed@/bin/sed 's,^,PREFIX ,'
}

preamble_turtle() {
    preamble_raw | @sed@/bin/sed 's,.*,@prefix & .,'
}

subtmpdir() {
    local name
    name=$(nonce 5)
    require_tmp
    @coreutils@/bin/mkdir "$tmp/$name"
    echo "$tmp/$name"
}

timestamp() {
    local now
    now=$(@coreutils@/bin/date +"${XSD_DATE_FMT}")
    echo "\"$now\"^^xsd:dateTime"
}

xml_pieces() {
    if [ $# -ne 2 ]; then exit_usage "xml_pieces /foo/bar file"; fi
    local file path
    path=$1
    file=$2
    pathregex=${path//\//\\/}
    itemsdir=$(subtmpdir)
    @xml2@/bin/xml2 < "$file" |
    @coreutils@/bin/csplit \
        --prefix "$itemsdir"/ \
        - \
        "/^${pathregex}$/" '{*}' \
        >/dev/null
    for f in "$itemsdir"/*; do
        @sed@/bin/sed -i \
            -e "/^${pathregex}\//!d" \
            -e "s,^${pathregex}\/,," \
            "$f"
    done
    echo "$itemsdir"
}

exit_usage() {
    local base
    base="usage: $me"
    case $# in
        0)  echo "$base COMMAND [ARG ...]" >&2
            echo "where COMMAND is one of" >&2
            declare -F |
            @grep@/bin/grep '^declare -f command_' |
            @sed@/bin/sed -e 's,^declare -f command_,    ,' \
                -e 's/_/-/g' |
            @coreutils@/bin/sort >&2
            ;;
        *)  echo "$base $@" >&2
            ;;
    esac
    exit 1
}

if [ $# -lt 1 ]; then exit_usage; fi
command=$(echo "$1" | tr - _)
shift
"command_$command" "$@"
