#!@bash@/bin/bash
set -euo pipefail
me=$(@coreutils@/bin/basename "${BASH_SOURCE[0]}")
here=$(@coreutils@/bin/dirname "${BASH_SOURCE[0]}")

XSD_DATE_FMT="%FT%T.%N%:z"
REDDIT_USER_AGENT="linux:org.amotlpaa.thing:v0.2.0 (by /u/stebulus)"

cleanup() { if [ -v tmp ]; then rm -rf "$tmp"; fi }
trap cleanup EXIT
tmp=$(@coreutils@/bin/mktemp --directory --tmpdir "$me".XXXXXXXX)

command_feed() {
    if [ $# -gt 0 ]; then preamble_turtle; fi
    for url in "$@"; do
        echo "<$url> a amfd:feed ."
    done
}

command_fetch() {
    local url fetchdir now extracted status
    for url in "$@"; do
        fetchdir=$(new_data_subdir)
        {
            preamble_turtle
            echo "<.> rdf:type amfd:fetch ;"
            echo "  amfd:fetch-url <$url> ;"
            now=$(timestamp)
            echo "  amfd:when-start $now ."
            @curl@/bin/curl \
                --compressed \
                --dump-header "$fetchdir"/headers \
                --location \
                --output "$fetchdir"/entity \
                --show-error \
                --silent \
                "$url"
            status=$(@coreutils@/bin/tr -d '\r' \
                < "$fetchdir"/headers |
                @awk@/bin/awk '
                    BEGIN { statusLine = 1 }
                    statusLine {
                        status = $2
                        statusLine = 0
                    }
                    /^$/ { statusLine = 1 }
                    END { print status }
                    ')
            case "$status" in
                2*) extracted=none
                    for type in rss atom reddit; do
                        if "$here/extract-$type" "$fetchdir"/entity 2>/dev/null; then
                            extracted=some
                        fi
                    done
                    case "$extracted" in
                        some) ;;
                        none) echo "<.> amfd:error \"extract\" ." ;;
                        *) echo "$me: internal error: extracted = $extracted" >&2
                           ;;
                    esac
                    ;;
                *)  echo "<.> amfd:error \"curl-${status:0:1}xx\" ."
                    ;;
            esac
            now=$(timestamp)
            echo "<.> amfd:when-end $now ."
        } >"$fetchdir"/facts.ttl
        echo "$fetchdir"/facts.ttl
    done
}

command_fetchable() {
    if [ $# -ne 1 ]; then exit_usage "fetchable DBDIR"; fi
    local fence
    fence=$(@coreutils@/bin/date +"${XSD_DATE_FMT}" --date "29 hours ago")
    command_query "$1" "
        SELECT ?url
        WHERE {
            ?url a amfd:feed .
            OPTIONAL {
                ?url ^amfd:fetch-url/amfd:when-end ?time .
                FILTER (?time > \"$fence\"^^xsd:dateTime)
            }
            FILTER (!bound(?time))
            OPTIONAL { ?url amfd:nope ?nope . }
            FILTER (!bound(?nope))
        }
        " |
    @jq@/bin/jq -r '.results.bindings | .[] | .url.value'
}

command_merge() {
    if [ $# -lt 1 ]; then exit_usage "merge DBDIR [FILE ...]"; fi
    local dbdir
    dbdir=$1
    shift
    if [ $# -eq 0 ]; then command_merge "$dbdir" -; fi
    for f in "$@"; do
        case "$f" in
            -) fullf="<stdin>" ;;
            *) fullf=$(@coreutils@/bin/readlink -e "$f") ;;
        esac
        g=$(nonce 20)
        {
            echo "# $fullf"
            @coreutils@/bin/date +"# ${XSD_DATE_FMT}"
            @jena@/bin/turtle "$f"
        } >"$dbdir/.new.$g"
        @coreutils@/bin/mv "$dbdir/.new.$g" "$dbdir/$g"
    done
}

command_nope() {
    local now
    if [ $# -ge 1 ]; then preamble_turtle; fi
    for url in "$@"; do
        now=$(timestamp)
        echo "<$url> amfd:nope [ amfd:when $now ] ."
    done
}

command_query() {
    if [ $# -ne 2 ]; then exit_usage "query DBDIR QUERY"; fi
    local dbdir query work
    dbdir=$1
    query=$2
    work=$(subtmpdir)
    @coreutils@/bin/cat "$dbdir"/* >"$work"/all-facts.nt
    {
        preamble_sparql
        echo "$query"
    } >"$work"/query.rq
    @jena@/bin/sparql \
        --results json \
        --data "$work"/all-facts.nt \
        --query "$work"/query.rq
}

command_reddit_auth() {
    local credsfile client_id client_secret redirect_uri
    case $# in
        1) credsfile=$1
           client_id=$(json_get .client_id "$credsfile")
           redirect_uri=$(json_get .redirect_uri "$credsfile")
           echo "https://www.reddit.com/api/v1/authorize?client_id=${client_id}&response_type=code&state=huzzah&redirect_uri=${redirect_uri}&duration=permanent&scope=read"
           ;;
        2) credsfile=$1
           code=$2
           client_id=$(json_get .client_id "$credsfile")
           client_secret=$(json_get .client_secret "$credsfile")
           redirect_uri=$(json_get .redirect_uri "$credsfile")
           @curl@/bin/curl --silent --show-error --fail \
               -XPOST \
               --data grant_type=authorization_code \
               --data code="$code" \
               --data redirect_uri="$redirect_uri" \
               --user "$client_id:$client_secret" \
               --user-agent "$REDDIT_USER_AGENT" \
               https://www.reddit.com/api/v1/access_token
           ;;
        *) exit_usage "reddit-auth CREDSFILE [CODE]"
           ;;
    esac
}

command_reddit_reauth() {
    if [ $# -ne 2 ]; then
        exit_usage "reddit-reauth CREDSFILE AUTHFILE"
    fi
    local authfile credsfile refresh_token suffix
    credsfile=$1
    authfile=$2
    client_id=$(json_get .client_id "$credsfile")
    client_secret=$(json_get .client_secret "$credsfile")
    redirect_uri=$(json_get .redirect_uri "$credsfile")
    refresh_token=$(json_get .refresh_token "$authfile")
    suffix=$(nonce 5)
    if @curl@/bin/curl --silent --show-error --fail \
        -XPOST \
        --data client_id="$client_id" \
        --data client_secret="$client_secret" \
        --data grant_type=refresh_token \
        --data refresh_token="$refresh_token" \
        --data scope=read \
        --data state=huzzah \
        --data duration=temporary \
        --data redirect_uri="$redirect_uri" \
        --user "$client_id:$client_secret" \
        --user-agent "$REDDIT_USER_AGENT" \
        https://www.reddit.com/api/v1/access_token \
        > "$tmp/$suffix"
    then
        @jq@/bin/jq \
            --arg refresh "$refresh_token" \
            'to_entries
              + [{"key": "refresh_token", "value": $refresh}]
              | from_entries' \
            "$tmp/$suffix" \
            > "${authfile}.new.${suffix}"
        @coreutils@/bin/mv "${authfile}.new.${suffix}" "${authfile}"
        json_get .expires_in "$authfile"
    else
        echo "$me: reddit reauthorization failed" >&2
        @coreutils@/bin/rm -f "${authfile}.new.${suffix}"
        return 1
    fi
}

command_review() {
    if [ $# -ne 0 ]; then exit_usage "review  # pipe from unreviewed"; fi
    now=$(timestamp)
    preamble_turtle
    echo
    @jq@/bin/jq --arg now "$now" -r '
        .results.bindings | .[] | [
            "# Title: \(.title.value)",
            "# Source: \(.sourceurl.value)",
            "# Date: \(.date.value)",
            "<\(.link.value)>",
            "  amfd:review [",
            "    amfd:worth-posting ? ;",
            "    amfd:when \($now)",
            "  ] .",
            ""
        ] | .[]
        '
}

command_unposted() {
    if [ $# -ne 1 ]; then exit_usage "unposted DBDIR"; fi
    command_query "$1" '
        SELECT ?link ?title ?sourceurl ?date
        WHERE {
            ?item a amfd:item ; amfd:link ?link .
            ?link amfd:review/amfd:worth-posting true .
            OPTIONAL { ?item dc:title ?title }
            OPTIONAL { ?item dc:source/amfd:fetch-url ?sourceurl }
            OPTIONAL { ?item dc:date ?date }
            OPTIONAL { ?link amfd:post ?post }
            FILTER (!bound(?post))
        }
        '
}

command_unreviewed() {
    if [ $# -ne 1 ]; then exit_usage "unreviewed DBDIR"; fi
    command_query "$1" '
        SELECT ?link ?title ?sourceurl ?date
        WHERE {
            {
                SELECT ?link (SAMPLE(?item) AS ?someitem)
                WHERE {
                    ?item a amfd:item ; amfd:link ?link .
                    OPTIONAL { ?link amfd:review ?review }
                    FILTER (!bound(?review))
                }
                GROUP BY ?link
            }
            {
                SELECT (SAMPLE(?fetch) AS ?somefetch)
                WHERE {
                    ?someitem dc:source ?fetch .
                    OPTIONAL { ?fetch amfd:fetch-url/amfd:nope ?nope . }
                    FILTER (!bound(?nope))
                }
            }
            OPTIONAL { ?someitem dc:title ?title }
            OPTIONAL { ?somefetch amfd:fetch-url ?sourceurl }
            OPTIONAL { ?someitem dc:date ?date }
        }
        '
}

json_get() {
    key=$1
    file=$2
    @jq@/bin/jq -r \
        --arg me "$me" \
        --arg key "$key" \
        --arg file "$file" \
        "$key"' // error("\($me): \($key) not found in \($file)")' \
        "$file"
}

new_data_subdir() {
    local chars d
    chars=$(nonce 20)
    @coreutils@/bin/mkdir -p "$chars"
    echo "$chars"
}

nonce() {
    @coreutils@/bin/dd if=/dev/urandom count="$1" bs=1 2>/dev/null |
    @coreutils@/bin/base32 |
    @coreutils@/bin/tr A-Z a-z
}

preamble_raw() {
    echo "amfd: <tag:amotlpaa.org,2016:fdfd/>"
    echo "amfdr: <tag:amotlpaa.org,2016:fdfd-reddit/>"
    echo "dc: <http://purl.org/dc/terms/>"
    echo "rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
    echo "xsd: <http://www.w3.org/2001/XMLSchema#>"
}

preamble_sparql() {
    preamble_raw | @sed@/bin/sed 's,^,PREFIX ,'
}

preamble_turtle() {
    preamble_raw | @sed@/bin/sed 's,.*,@prefix & .,'
}

subtmpdir() {
    local name
    name=$(nonce 5)
    @coreutils@/bin/mkdir "$tmp/$name"
    echo "$tmp/$name"
}

timestamp() {
    local now
    now=$(@coreutils@/bin/date +"${XSD_DATE_FMT}")
    echo "\"$now\"^^xsd:dateTime"
}

exit_usage() {
    local base
    base="usage: $me"
    case $# in
        0)  echo "$base COMMAND [ARG ...]" >&2
            echo "where COMMAND is one of" >&2
            declare -F |
            @grep@/bin/grep '^declare -f command_' |
            @sed@/bin/sed -e 's,^declare -f command_,    ,' \
                -e 's/_/-/g' |
            @coreutils@/bin/sort >&2
            ;;
        *)  echo "$base $@" >&2
            ;;
    esac
    exit 1
}

if [ $# -lt 1 ]; then exit_usage; fi
command=$(echo "$1" | tr - _)
shift
"command_$command" "$@"
